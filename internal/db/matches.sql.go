// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package db

import (
	"context"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
  start_iso, end_iso, date_raw, time_raw, end_time_raw, weekday,
  league, team, opponent, home_team, away_team, venue, court, city,
  gather_time, gather_place, match_number, referees, notes,
  played, goals_for, goals_against, player_notes,
  top_scorer_team, top_scorer_opponent
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, start_iso, end_iso, date_raw, time_raw, end_time_raw, weekday, league, team, opponent, home_team, away_team, venue, court, city, gather_time, gather_place, match_number, referees, notes, played, goals_for, goals_against, player_notes, top_scorer_team, top_scorer_opponent
`

type CreateMatchParams struct {
    StartIso     *string
    EndIso       *string
    DateRaw      *string
    TimeRaw      *string
    EndTimeRaw   *string
    Weekday      *string
    League       *string
    Team         *string
    Opponent     *string
    HomeTeam     *string
    AwayTeam     *string
    Venue        *string
    Court        *string
    City         *string
    GatherTime   *string
    GatherPlace  *string
    MatchNumber  *string
    Referees     *string
    Notes        *string
    Played       *int64
    GoalsFor     *int64
    GoalsAgainst *int64
    PlayerNotes  *string
    TopScorerTeam *string
    TopScorerOpponent *string
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch,
		arg.StartIso,
		arg.EndIso,
		arg.DateRaw,
		arg.TimeRaw,
		arg.EndTimeRaw,
		arg.Weekday,
		arg.League,
		arg.Team,
		arg.Opponent,
		arg.HomeTeam,
		arg.AwayTeam,
		arg.Venue,
		arg.Court,
		arg.City,
		arg.GatherTime,
		arg.GatherPlace,
		arg.MatchNumber,
		arg.Referees,
		arg.Notes,
		arg.Played,
		arg.GoalsFor,
		arg.GoalsAgainst,
		arg.PlayerNotes,
		arg.TopScorerTeam,
		arg.TopScorerOpponent,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.StartIso,
		&i.EndIso,
		&i.DateRaw,
		&i.TimeRaw,
		&i.EndTimeRaw,
		&i.Weekday,
		&i.League,
		&i.Team,
		&i.Opponent,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Venue,
		&i.Court,
		&i.City,
		&i.GatherTime,
		&i.GatherPlace,
		&i.MatchNumber,
		&i.Referees,
		&i.Notes,
		&i.Played,
		&i.GoalsFor,
		&i.GoalsAgainst,
		&i.PlayerNotes,
		&i.TopScorerTeam,
		&i.TopScorerOpponent,
	)
	return i, err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches WHERE id = ?
`

func (q *Queries) DeleteMatch(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMatch, id)
	return err
}

const deleteAllMatches = `-- name: DeleteAllMatches :exec
DELETE FROM matches
`

func (q *Queries) DeleteAllMatches(ctx context.Context) (int64, error) {
    res, err := q.db.ExecContext(ctx, deleteAllMatches)
    if err != nil { return 0, err }
    n, _ := res.RowsAffected()
    return n, nil
}

const getMatch = `-- name: GetMatch :one
SELECT id, start_iso, end_iso, date_raw, time_raw, end_time_raw, weekday, league, team, opponent, home_team, away_team, venue, court, city, gather_time, gather_place, match_number, referees, notes, played, goals_for, goals_against, player_notes, top_scorer_team, top_scorer_opponent FROM matches WHERE id = ?
`

func (q *Queries) GetMatch(ctx context.Context, id int64) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatch, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.StartIso,
		&i.EndIso,
		&i.DateRaw,
		&i.TimeRaw,
		&i.EndTimeRaw,
		&i.Weekday,
		&i.League,
		&i.Team,
		&i.Opponent,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Venue,
		&i.Court,
		&i.City,
		&i.GatherTime,
		&i.GatherPlace,
		&i.MatchNumber,
		&i.Referees,
		&i.Notes,
		&i.Played,
		&i.GoalsFor,
		&i.GoalsAgainst,
		&i.PlayerNotes,
		&i.TopScorerTeam,
		&i.TopScorerOpponent,
	)
	return i, err
}

const listMatches = `-- name: ListMatches :many
SELECT id, start_iso, end_iso, date_raw, time_raw, end_time_raw, weekday, league, team, opponent, home_team, away_team, venue, court, city, gather_time, gather_place, match_number, referees, notes, played, goals_for, goals_against, player_notes, top_scorer_team, top_scorer_opponent FROM matches
ORDER BY (start_iso IS NULL), start_iso, id
`

func (q *Queries) ListMatches(ctx context.Context) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, listMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.StartIso,
			&i.EndIso,
			&i.DateRaw,
			&i.TimeRaw,
			&i.EndTimeRaw,
			&i.Weekday,
			&i.League,
			&i.Team,
			&i.Opponent,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Venue,
			&i.Court,
			&i.City,
			&i.GatherTime,
			&i.GatherPlace,
			&i.MatchNumber,
			&i.Referees,
			&i.Notes,
			&i.Played,
			&i.GoalsFor,
			&i.GoalsAgainst,
			&i.PlayerNotes,
			&i.TopScorerTeam,
			&i.TopScorerOpponent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :one
UPDATE matches
SET
  start_iso = ?,
  end_iso = ?,
  date_raw = ?,
  time_raw = ?,
  end_time_raw = ?,
  weekday = ?,
  league = ?,
  team = ?,
  opponent = ?,
  home_team = ?,
  away_team = ?,
  venue = ?,
  court = ?,
  city = ?,
  gather_time = ?,
  gather_place = ?,
  match_number = ?,
  referees = ?,
  notes = ?,
  played = ?,
  goals_for = ?,
  goals_against = ?,
  player_notes = ?,
  top_scorer_team = ?,
  top_scorer_opponent = ?
WHERE id = ?
RETURNING id, start_iso, end_iso, date_raw, time_raw, end_time_raw, weekday, league, team, opponent, home_team, away_team, venue, court, city, gather_time, gather_place, match_number, referees, notes, played, goals_for, goals_against, player_notes, top_scorer_team, top_scorer_opponent
`

type UpdateMatchParams struct {
    StartIso     *string
    EndIso       *string
    DateRaw      *string
    TimeRaw      *string
    EndTimeRaw   *string
    Weekday      *string
    League       *string
    Team         *string
    Opponent     *string
    HomeTeam     *string
    AwayTeam     *string
    Venue        *string
    Court        *string
    City         *string
    GatherTime   *string
    GatherPlace  *string
    MatchNumber  *string
    Referees     *string
    Notes        *string
    Played       *int64
    GoalsFor     *int64
    GoalsAgainst *int64
    PlayerNotes  *string
    TopScorerTeam *string
    TopScorerOpponent *string
    ID           int64
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, updateMatch,
		arg.StartIso,
		arg.EndIso,
		arg.DateRaw,
		arg.TimeRaw,
		arg.EndTimeRaw,
		arg.Weekday,
		arg.League,
		arg.Team,
		arg.Opponent,
		arg.HomeTeam,
		arg.AwayTeam,
		arg.Venue,
		arg.Court,
		arg.City,
		arg.GatherTime,
		arg.GatherPlace,
		arg.MatchNumber,
		arg.Referees,
		arg.Notes,
		arg.Played,
		arg.GoalsFor,
		arg.GoalsAgainst,
		arg.PlayerNotes,
		arg.TopScorerTeam,
		arg.TopScorerOpponent,
		arg.ID,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.StartIso,
		&i.EndIso,
		&i.DateRaw,
		&i.TimeRaw,
		&i.EndTimeRaw,
		&i.Weekday,
		&i.League,
		&i.Team,
		&i.Opponent,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Venue,
		&i.Court,
		&i.City,
		&i.GatherTime,
		&i.GatherPlace,
		&i.MatchNumber,
		&i.Referees,
		&i.Notes,
		&i.Played,
		&i.GoalsFor,
		&i.GoalsAgainst,
		&i.PlayerNotes,
		&i.TopScorerTeam,
		&i.TopScorerOpponent,
	)
	return i, err
}
